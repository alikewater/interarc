

子线程中对变量的改变可以在主线程中反映出来，主线程中对变量的改变在子线程中不可见。子线程中对同一实例对象的成员变量
的改变可见。


 1.基本的多线程并发编程……
    1.1 线程概念
      线程构造方式：传递一个Thread的实例，或者传递一个实现Runnable接口的对象，并发访问的代码段可以是run方法本身，
      也可以是run方法中调用目标对象的相关方法。
      线程发生异常如果不捕获的话，JVM会自动停止线程的后续工作。
      线程异常发生的处理方式：  日志记录后继续执行，或者回滚已经执行的内容。
    1.2 线程同步
      synchronized 线程同步锁重量级锁。锁是基于具体对象实例实现的，对象头部包含了锁的信息。具体又分为类锁和对象锁，
      类锁锁的是类class对象，对象锁锁的是具体class对象实例化出来的类的实例。sychronized结合notify和wait实现线程见同步。wait调用
      释放锁，notify调用不释放锁，因此notify实现同步不具备实时性。
      volatile关键字线程可见性，不保证原子性。结合volatile和CAS(Compare and Set)保证原子性。AtomicXXX数据类型通过该方法保证原子性。
      AQS通过采用CAS结合CLH队列实现高效率的线程并发控制，JUC包中的RetrenLock/Condition/CountDownLunch/Semaphore都属于这一体系。
      
   1.3 同步类容器和并发类容器
      线程安全的容器 Vector替代List， HashTable替换HashMap.

      立足于多线程，高并发的容器：
      concurrentHashMap 和CopyOnWrite容器

      ConcurrentSkipListMap

      ConcurrentHashMap 通过分段将锁粒度细化。segment设计使得整个容器分为n个小区域。每个小区域为一个锁单元，最高支持16个段
      CopyOnWriteArrayList 和CopyOnWriteArraySet.当我按一个容器进行写操作时，不是直接操作当前容器，现将当前容器进行拷贝，复制出
      一个和元容器一样的副本，在新的副本上进行操作，然后再切换容器指向。实现了读写分离的思想，主要用于读多写少的场景。写太多时，复制的
      负担过重，不适用。多个写不能并发，是加锁实现的

   1.4 队列
      Queue:
      高性能队列(非阻塞)： ConcurrentLinkQueue 基于链接节点的无界队列，不允许null元素  add和offer加入元素，这两个方法在该类中无区别。
       pull和peak取出元素，前者删除元素，后者不会.
      阻塞队列：BlockingQueue

      ArrayBlockingQueue 基于数组的阻塞队列实现，没有实现读写分离，读写段不能完全同时进行，先进先出，有界队列

      LinkedBlockingQueue 基于链表实现的阻塞队列，内部由链表实现的存储，实现了读写分离（采用了读写分离的两个锁），无界队列

      SynchronousQueue 一种没有缓冲的队列，生产者生产的数据直接被消费者消费,这种队列只先进行take等待，再往里面加add元素，立即获得处理
      peek poll 不阻塞，没有元素返回空，add不允许直接添加元素，需要有take调用在先，否则抛出异常。offer放入无阻塞，没有take调用在先时不成功。
      put阻塞放入，没有take调用时，一直尝试添加。

      PriorityBlockingQueue 基于优先级的队列，无界队列，公平锁

      DelayQueue:带有延时的queue,元素要实现Delayed接口，用于时间排序和获取时间。适用于根据特定延时优先级进行元素获取。

      Dequeue 允许在队列的头部和尾部入队和出队
          LinkedBlockingDequeue 一种Dequeue的实现，没有实现读写分离，其高并发性能低于其他的BlockingQueue，同时也低于
          ConcurrentLinkedQueue 高并发的Deque实现
          
   1.5 线程设计模式
     Master--Worker模式: Master维护工作队列、Woker容器和结果收集容器。 Worker持有工作队列和结果收集容器，从工作队列获取任务执行，并存储结果到
     结果收集容器。
     Futrue模式 ，调用之后立即返回一个Future包装对象，然后后台启动新线程抓去真实数据填充到Future对象，Futrue对象内部的容器负责进行同步协作。
     生产者--消费者模式
     解耦和同步的使用。通过内部的容器（Queue）进行生产和消费段的解耦合，同时利用容器的存取同步实现
   
